Returning Static Data: The get_system_name function now returns a pointer to static data (unameData.nodename) instead of a local variable, avoiding the issue of returning a pointer to a local variable.

The #ifndef, #define, and #endif directives are used in C/C++ to prevent multiple inclusions of the same header file, a technique known as an include guard.

fgets is used as char* string, then size of string max and then where to read the filefrom that is stdin or file pointer.

To check your current username, type the command "whoami" in the terminal.
To check your system hostname, type the command "hostname" in the terminal.

snprintf is used to format and store a string into the display_path buffer. It does not directly produce output to the terminal.

#include <unistd.h>: Includes the POSIX API, providing access to system calls like getcwd (get current working directory).

struct utsname {
    char sysname[];    /* Operating system name (e.g., "Linux") */
    char nodename[];   /* Name within "some implementation-defined network" */
    char release[];    /* OS release (e.g., "2.6.28") */
    char version[];    /* OS version */
    char machine[];    /* Hardware identifier */
};

struct passwd {
    char   *pw_name;       /* username */
    char   *pw_passwd;     /* user password */
    uid_t   pw_uid;        /* user ID */
    gid_t   pw_gid;        /* group ID */
    char   *pw_gecos;      /* user information */
    char   *pw_dir;        /* home directory */
    char   *pw_shell;      /* shell program */
};

getuid(): This function returns the real user ID of the calling process. The user ID is an integer that uniquely identifies a user in the system.

getpwuid(uid_t uid): This function takes a user ID and returns a pointer to a struct passwd that contains information about the user, such as username, user ID, group ID, home directory, and shell.

The unameData structure is declared as static, which means its value persists across function calls. This ensures that the memory is not freed after the function returns, preventing the returned pointer from becoming invalid.

Color Coding:

Blue (\033[0;34m): Used for directories.
Green (\033[0;32m): Used for executable files (if the user has execute permissions).
White (\033[0;37m): Used for regular files.


strtok(cmd, " \t"): Strips out any leading or trailing spaces and tabs from the command.

The strchr function in C is used to locate the first occurrence of a character in a string. Here's a detailed breakdown of what strchr(command, '&') is doing in your code:

It seems that the cd command was processed, but the prompt wasn't updated to reflect the new directory. The issue might be due to the way cd is handled. In most shell implementations, cd is a built-in command because it modifies the shell's current working directory, and this change needs to persist in the shell process.

Addressing the cd Command Handling:
Implement cd as a Built-in Command: Since cd needs to change the working directory of the shell itself (not just in a child process), you must handle it directly in the shell process before forking.

signal Function Syntax:
void (*signal(int sig, void (*handler)(int)))(int);

pid_t waitpid(pid_t pid, int *status, int options);
Purpose: Specifies which child process to wait for.
Values:
-1: Waits for any child process (similar to wait).
0: Waits for any child process in the same process group as the calling process.
> 0: Waits for the child process with the specified process ID (pid).
< -1: Waits for any child process in the process group whose ID is -pid

The status contains information about how the child process terminated (e.g., whether it exited normally, was killed by a signal, etc.).


 (Default Behavior)

Description: When you use 0 as the options argument, waitpid behaves in the traditional blocking mode. It waits for a child process to change its state, such as terminating or stopping.
Behavior:
Blocking: The function call will block (i.e., pause execution) until at least one child process changes state.
Child State Change: This includes scenarios where a child process exits, is stopped by a signal, or resumes if it was previously stopped.
WNOHANG

Description: The WNOHANG option makes waitpid non-blocking. It allows the function to return immediately if no child process has exited.
Behavior:
Non-Blocking: If no child processes have changed state by the time waitpid is called, it returns 0 right away without blocking the execution of your program.
Usage: This is useful in scenarios where you want to periodically check the status of child processes without pausing execution (e.g., in a loop or asynchronous operations).
WUNTRACED

Description: The WUNTRACED option tells waitpid to return information if a child process has stopped (e.g., due to receiving a signal) but not yet terminated.
Behavior:
Stopped Processes: If a child process is stopped (for example, by receiving a SIGSTOP, SIGTSTP, SIGTTIN, or SIGTTOU signal), waitpid will return its process ID and provide information about the stopping signal.
Use Case: This is useful when you want to track processes that are stopped due to signals and potentially handle them accordingly, even if they haven't exited yet.
WCONTINUED

Description: The WCONTINUED option allows waitpid to return when a stopped child process resumes execution due to receiving the SIGCONT signal.
Behavior:
Resumed Processes: If a previously stopped process has been resumed with SIGCONT, waitpid will return information about this event.
Use Case: This is useful in scenarios where you need to monitor the state of processes that have been stopped and then continued, such as managing a set of background jobs that might be interrupted and later resumed.

If waitpid returns a positive value, it indicates the process ID (pid) of a child process that has changed state. The value is greater than zero if a specific child process has exited or stopped.

strtok uses a single character or a string as a delimiter, but strsep can handle multi-character delimiters more flexibly.
strsep modifies the pointer passed to it, allowing for easier splitting of the command when using pipes.

strtok(cmd, " \t\n"): This call splits the string cmd into tokens using space, tab, or newline as delimiters. On the first call, cmd points to the command string.
cmd = NULL;: After the first token is extracted, cmd is set to NULL to ensure subsequent calls to strtok continue from where the previous call left off.

args[argc] = NULL;: The array is null-terminated to mark the end of the arguments.



memmove is a standard C library function that copies a block of memory from one location to another.
Parameters:
&command_log[0]: The destination address (starting from the first element).
&command_log[1]: The source address (starting from the second element).
sizeof(char*) * (MAX_LOG_SIZE - 1): The number of bytes to copy. This expression multiplies the size of a pointer (char*) by the number of elements being moved (MAX_LOG_SIZE - 1).
Why memmove?
memmove is used instead of memcpy because it correctly handles overlapping memory regions. In this case, the source and destination overlap because elements are being shifted within the same array. memmove ensures that the data is moved safely, even if the source and destination overlap.


The code snippet provided is constructing a single string (log_entry) from the command and its arguments, which will then be stored in the log if the command is valid. Here's a step-by-step breakdown of what each part does:

1. char log_entry[4096];
This declares a character array log_entry with a size of 4096 bytes. This buffer will hold the complete command along with its arguments, all in one string.
2. snprintf(log_entry, sizeof(log_entry), "%s", args[0]);
Purpose: Initializes log_entry with the command (the first argument).
Details:
snprintf is a safer version of sprintf that includes bounds checking. It formats the string and writes it to the log_entry buffer.
"%s": This format specifier tells snprintf to write the string pointed to by args[0] into log_entry.
sizeof(log_entry): Ensures that no more than 4096 bytes are written to avoid buffer overflow.
After this line, log_entry contains the command (e.g., "reveal" if args[0] was "reveal").
3. for (int i = 1; i < argc; i++) { snprintf(log_entry + strlen(log_entry), sizeof(log_entry) - strlen(log_entry), " %s", args[i]); }
Purpose: Appends each argument to the log_entry string, separated by spaces.
Details:
The for loop starts from i = 1 to skip the command (already added) and iterates through all the arguments provided in args[].
log_entry + strlen(log_entry): This calculates the position in log_entry where the next argument should be appended (i.e., after the current end of the string).
sizeof(log_entry) - strlen(log_entry): Ensures that snprintf does not write beyond the remaining space in log_entry.
" %s": Appends a space followed by the next argument (args[i]) to the current log_entry string.
By the end of the loop, log_entry contains the entire command with all its arguments in a single string.
Example:
Let's say the command is reveal with the arguments test, -a, and -l:

Initial log_entry: After the first snprintf, log_entry is "reveal".
After 1st iteration (i = 1): log_entry becomes "reveal test".
After 2nd iteration (i = 2): log_entry becomes "reveal test -a".
After 3rd iteration (i = 3): log_entry becomes "reveal test -a -l".

process_id: The ID of the process.
pgrp: The process group ID.
session: The session ID.
tty_nr: The terminal number.
tpgid: The ID of the foreground process group.
comm: The name of the executable.
state: The current state of the process (e.g., running, sleeping).
vsize: The virtual memory size of the process.



Example Walkthrough:
Suppose the input is: "ls & pwd; echo Hello & date".

First Command (ls & pwd)

Tokenized into: "ls & pwd"
Ampersand Count: 1
Sub-commands: "ls" and "pwd"
Execution:
"ls" is executed in the background.
"pwd" is executed in the foreground (since it's the last part and ampersand_count becomes zero).
Second Command (echo Hello & date)

Tokenized into: "echo Hello & date"
Ampersand Count: 1
Sub-commands: "echo Hello" and "date"
Execution:
"echo Hello" is executed in the background.
"date" is executed in the foreground.
This structure enables the shell to handle complex command inputs efficiently, managing both sequential and parallel (background) execution.